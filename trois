#!/usr/bin/env python3

import argparse
import socket
import threading
import time
import os
import hashlib
import secrets
import logging
import base64
import uuid
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec, rsa
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import signal_protocol  # Assume you've installed the signal-protocol-python library

# Configure logging
logging.basicConfig(filename='secure_scanner.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SecurePortScanner:
    def __init__(self):
        # ... (ECC key generation and other initialization) ...
        self.signal_store = signal_protocol.InMemoryStore()  # Or a persistent store

    def generate_changelog_key(self):
        # ... (same as before) ...

    def encrypt_changelog(self, data):
        # ... (same as before) ...

    def generate_user_credentials(self):
        # ... (same as before) ...

    def scan_port(self, host, port, timeout=1):
        try:
            # ... (original code) ...
        except socket.timeout:
            logger.warning(f"Timeout scanning port {port} on {host}")
            return port, False  # Consider retry logic
        except ConnectionRefusedError:
            logger.info(f"Connection refused to port {port} on {host}")
            return port, False
        except OSError as e:
            logger.error(f"OSError scanning port {port} on {host}: {e}")
            # ... (handle critical error, potentially stop scanning) ...
        except Exception as e:
            logger.exception(f"Unexpected error scanning port {port} on {host}: {e}")
            # ... (handle or re-raise) ...

    def port_scan(self, host, start_port, end_port):
        # ... (same as before) ...

    def encrypted_chat_server(self, host='0.0.0.0', port=8888):
        # ... (create server socket) ...

        while True:
            client, addr = server.accept()
            threading.Thread(target=self.handle_client, args=(client, addr)).start()

    def handle_client(self, client, addr):
        """Handle chat client connection with Signal Protocol"""
        try:
            # ... (establish Signal Protocol session) ...
            recipient_id = "recipient_id"  # Replace with actual recipient ID
            device_id = 1  # Replace with actual device ID
            session_builder = signal_protocol.SessionBuilder(self.signal_store, recipient_id, device_id)
            # ... (exchange pre-keys, establish session) ...
            session_cipher = signal_protocol.SessionCipher(self.signal_store, recipient_id, device_id)

            while True:
                try:
                    data = client.recv(1024)
                    if not data:
                        break
                    # Decrypt message using Signal Protocol
                    plaintext = session_cipher.decrypt(data)
                    logger.info(f"Received message from {addr}: {plaintext.decode()}")
                    # ... (process plaintext message) ...
                except Exception as e:
                    logger.error(f"Error handling client {addr}: {e}")
                    break

            client.close()
        except Exception as e:
            logger.exception(f"Error establishing Signal Protocol session with {addr}: {e}")


def main():
    # ... (argument parsing) ...

    scanner = SecurePortScanner()

    # ... (user credentials generation) ...

    if args.chat:
        scanner.encrypted_chat_server()
    else:
        # ... (port scanning and changelog update) ...

def install():
    """Encrypted installation with persistence"""
    # ... (generate RSA key pair) ...
    public_key, private_key = rsa.newkeys(2048)

    # ... (encrypt sensitive data with public key) ...
    encrypted_data = rsa.encrypt(data.encode(), public_key)

    # ... (store encrypted data and public key securely) ...
    with open("config.encrypted", "wb") as f:
        f.write(encrypted_data)
    # ... (store public key securely) ...

if __name__ == "__main__":
    if os.path.exists("config.encrypted"):
        # If installed, run main function
        main()
    else:
        # If not installed, run installation
        install()
